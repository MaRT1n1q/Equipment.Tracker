# Комплексный аудит Equipment Tracker

## Сводка ключевых рисков

- **Объём данных не ограничен** – IPC-обработчики возвращают полные таблицы заявок и выходов без пагинации или фильтрации на стороне БД, из-за чего и main-процесс, и React-рендер деградируют при росте данных.
- **Рендеринг списков не масштабируется** – таблицы заявок и выходов создают сотни вложенных элементов без виртуализации и повторно парсят данные на каждом рендере.
- **Инфраструктура БД/бэкапов не защищает от блокировок и повреждений** – отсутствуют WAL/busy_timeout, копирование файлов выполняется прямым `copyFile`, экспорт и напоминания делают полные сканы.
- **UX и состояние склонны к дрейфу** – глобальные хоткеи перехватывают ввод, черновики навсегда остаются в LocalStorage, а legacy-записи выходов невозможно отредактировать из-за слишком жёстких проверок.
- **Отсутствует автоматическое покрытие** – проект полагается на ручное тестирование, что делает регрессии и ошибки миграций вероятными.

Ниже перечислены конкретные проблемы и пошаговые рекомендации по устранению.

## Детальный список проблем

### 1. [High] Нет ограничений на выборки `requests` и `employee_exits`

**Файлы:** `electron/ipc/requests.ts`, `electron/ipc/employeeExits.ts`, `src/hooks/useRequests.ts`, `src/hooks/useEmployeeExits.ts`

Main-процесс всегда выполняет `select('*')` и возвращает весь объём данных. При 10k+ записей каждая перерисовка страницы приводит к десяткам мегабайт данных и блокировкам render-потока.

**Шаги устранения:**

1. Добавить в IPC слой поддержку пагинации и серверной фильтрации (query-параметры: `limit`, `offset`, `search`, `status`).
2. Обновить React Query-хуки, чтобы они передавали параметры и кешировали постраничные ответы (`getNextPageParam`).
3. На UI реализовать виртуальный скролл/страницы и отображение счётчиков на основе метаданных (`total`, `pages`).

### 2. [High] Таблицы заявок и выходов рендерят весь список без виртуализации

**Файлы:** `src/components/RequestsTable.tsx`, `src/components/EmployeeExitTable.tsx`

Каждый элемент списка – комплексная карточка с тултипами/диалогами. При сотнях записей React создаёт тысячи DOM-нод и пересоздаёт обработчики, что приводит к заметным лагам.

**Шаги устранения:**

1. Внедрить виртуальный список (React Window / TanStack Virtual) для основных таблиц.
2. Вынести карточку заявки/выхода в `memo`-компонент с `useMemo` для производных значений (дат, статусов).
3. Добавить skeleton/placeholder на уровне виртуализированного контейнера, чтобы не держать старые элементы в памяти.

### 3. [Medium] Фильтрация и поиск работают исключительно на клиенте

**Файлы:** `src/components/RequestsView.tsx`, `src/components/EmployeeExitView.tsx`, `src/components/Dashboard.tsx`

Каждый ввод символа инициирует полное копирование массива и множественные `toLowerCase()` / `parseExitEquipmentList` вызовы. При тысячах строк даже 300 мс debounce не спасает.

**Шаги устранения:**

1. Перенести первичный поиск/фильтры в SQL (`WHERE employee_name LIKE ? OR login LIKE ?`).
2. Хранить нормализованный поисковый индекс (например, `search_vector` или столбец с lower-case значением) и использовать `LIKE`/FTS.
3. На клиенте оставлять только лёгкие фильтры (визуальная сегментация, сортировка уже выбранной страницы).

### 4. [Medium] Планировщик напоминаний ежеминутно сканирует всю таблицу выходов

**Файлы:** `electron/notifications.ts`

`fetchUpcomingExits` выбирает **все** строки и фильтрует их в JS при каждом таймере. При росте данных scheduler тратит CPU вхолостую.

**Шаги устранения:**

1. Переписать запрос на SQL с `WHERE exit_date BETWEEN today AND tomorrow` и `is_completed = 0`.
2. Ограничить набор колонок (`select('id','employee_name','exit_date')`).
3. Добавить к `exit_date`/`is_completed` соответствующий индекс (см. Проблема 5).

### 5. [High] Недостаток индексов для часто используемых фильтров

**Файлы:** `electron/database.ts`

Создаются индексы только по `created_at`, `exit_date` и FK. Фильтры UI используют `is_issued`, `return_required`, `return_completed`, `login`, `sd_number`, `is_completed`, но они без индексов, что приводит к Table Scan.

**Шаги устранения:**

1. В `ensureSchema` добавить индексы: `idx_requests_is_issued`, `idx_requests_return_required`, `idx_requests_login`, `idx_employee_exits_is_completed`.
2. Вынести создание индексов в миграции, чтобы существующие БД обновлялись безопасно.
3. После добавления индексов прогнать `ANALYZE`/`VACUUM` и убедиться, что планировщик использует новые индексы.

### 6. [Medium] Подключение к SQLite не включает WAL и `busy_timeout`

**Файлы:** `electron/database.ts`

Конфигурация пула ограничивается `PRAGMA foreign_keys = ON`. При одновременных операциях (бэкап, scheduler, массовое обновление) возникают `SQLITE_BUSY`, а файлы могут копироваться в несогласованном состоянии.

**Шаги устранения:**

1. После создания подключения выполнить `PRAGMA journal_mode = WAL`, `PRAGMA busy_timeout = 5000`, `PRAGMA synchronous = NORMAL`.
2. Перед copy/backup использовать `database.raw('BEGIN IMMEDIATE')` или встроенный SQLite backup API.
3. Зафиксировать параметры в миграциях и документировать их в README.

### 7. [High] Резервные копии и восстановление делают "тупое" копирование файлов

**Файлы:** `electron/ipc/backup.ts`

`createAutomaticBackup`/`create-backup` вызывают `fs.copyFile` по живой БД. Нет проверок контрольной суммы, нет уведомления UI об ошибках, и нет ротации логов.

**Шаги устранения:**

1. Использовать `VACUUM INTO` или API sqlite `.backup` через `better-sqlite3`/`sqlite3` binding для атомарных копий.
2. Возвращать расширенный результат (путь, размер, длительность) и отображать в `SettingsModal`.
3. При восстановлении валидировать версию схемы (например, хранить `db_meta` таблицу) и не удалять emergency-файл до успешного `PRAGMA integrity_check`.

### 8. [Medium] Экспорт CSV блокирует основной поток

**Файлы:** `electron/ipc/employeeExits.ts`

Handler синхронно формирует огромную строку и пишет её через `fs.writeFileSync`, блокируя main-процесс до окончания операции.

**Шаги устранения:**

1. Перейти на потоковую запись (`createWriteStream`) и асинхронный `await fs.promises.writeFile`.
2. Формировать CSV построчно (generator) без промежуточной конкатенации гигантской строки.
3. Рассмотреть вынесение экспорта в отдельный worker-thread, чтобы не замораживать UI.

### 9. [High] Нельзя отредактировать legacy-записи выходов без серийных номеров

**Файлы:** `src/components/AddEmployeeExitModal.tsx`, `src/components/EditEmployeeExitModal.tsx`, `src/lib/employeeExitEquipment.ts`

`parseExitEquipmentList` специально поддерживает старый формат (строки без серийников). Но модальные окна требуют наличие **и имени, и сериала**. Пользователь не может сохранить запись, созданную до миграции, пока не заполнит вымышленные серийники.

**Шаги устранения:**

1. Разрешить пустой `serial` в клиентах и в `createEmployeeExitSchema` (опциональное поле).
2. Во время загрузки legacy-записей автоматически подставлять заглушку/"N/A" и сохранять исходный формат при отсутствии сериалов.
3. Добавить миграцию, которая нормализует старые `equipment_list` в JSON-формат с пустыми serial и избавляет от двойной логики парсинга.

### 10. [Medium] Черновики форм навсегда остаются в LocalStorage

**Файлы:** `src/hooks/useRequestFormState.ts`, `src/components/EditEmployeeExitModal.tsx`

Каждое открытие модалки создаёт уникальный ключ (`equipment-tracker:edit-request-<id>`). Ключи никогда не очищаются, даже после успешного сохранения или удаления заявки.

**Шаги устранения:**

1. После успешного `create/update` удалять соответствующий ключ (`localStorage.removeItem`).
2. В `usePersistentState` добавить опцию TTL/GC (например, хранить timestamp, чистить устаревшие записи при загрузке).
3. Рассмотреть перенос длительных черновиков в IndexedDB с лимитом или отключить персистентность для edit-модалок вовсе.

### 11. [Medium] Глобальные хоткеи игнорируют контекст ввода

**Файлы:** `src/hooks/useKeyboardShortcut.ts`, `RequestsView.tsx`, `EmployeeExitView.tsx`

`Ctrl+F`/`Ctrl+Shift+F` ловятся даже внутри модальных форм и `textarea`, т.к. `useKeyboardShortcut` не проверяет `event.target`. Это сбрасывает ввод и блокирует стандартные сочетания.

**Шаги устранения:**

1. В `useKeyboardShortcut` пропускать события, пришедшие от `input`, `textarea`, `[contentEditable]` или при активном модальном окне.
2. Экспортировать из модалок флаг "isModalOpen" и отключать хоткеи, пока пользователь набирает данные.
3. Добавить unit-тесты/Storybook-сценарии, гарантирующие, что хоткей не срабатывает при фокусе в поле.

### 12. [Medium] `parseExitEquipmentList` выполняется на каждом рендере

**Файлы:** `src/components/EmployeeExitTable.tsx`, `src/components/EmployeeExitView.tsx`, `src/lib/employeeExitEquipment.ts`

Parser JSON/строк вызывается в `map` при каждом обновлении поисковой строки или выделения, хотя результат идентичен до следующего запроса.

**Шаги устранения:**

1. На уровне IPC преобразовывать `equipment_list` в массив (например, `equipment_items_raw`) и кэшировать в React Query.
2. Временно можно оборачивать `parseExitEquipmentList` в `useMemo` по `exit.equipment_list`.
3. Стандартизовать хранение оборудования в отдельной таблице (по аналогии с `equipment_items`).

### 13. [Medium] Dashboard-поиск не масштабируется

**Файлы:** `src/components/Dashboard.tsx`

Поиск объединяет заявки и выходы, создаёт большие строки, вызывает `toLowerCase`, `map`, `reduce` на каждом нажатии клавиши без ограничений и без worker-потока.

**Шаги устранения:**

1. Дать поиску доступ к тем же постраничным API, что и списки, и отображать предложения через IPC (`search` endpoint).
2. Минимизировать работу в UI: кешировать результаты последнего запроса, использовать web worker для построения индекса.
3. Ограничить число просматриваемых результатов (например, запросить только top-20 из API вместо slice на клиенте).

### 14. [Medium] Отсутствуют автоматические регрессионные проверки

**Файлы:** `package.json`, отсутствуют каталоги `tests/`

Проект полагается на ручные проверки. Нет unit-тестов для IPC, нет smoke-тестов миграций БД, нет e2e сценариев Electron. Любая правка в базе или IPC может сломать прод.

**Шаги устранения:**

1. Ввести Vitest/React Testing Library для критичных хуков (`useRequests`, `useEmployeeExits`).
2. Добавить интеграционный тест миграций: поднимать временную SQLite, запускать `ensureSchema`, проверять целостность.
3. Настроить CI (GitHub Actions) на `npm run lint` + `npm run build:ci` + тесты, чтобы PR без зелёных чеков не мёрджились.
